\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand\HyField@AuxAddToFields[1]{}
\providecommand\HyField@AuxAddToCoFields[2]{}
\providecommand\tcolorbox@label[2]{}
\babel@aux{english}{}
\citation{fccm17}
\citation{fccm18}
\citation{camb}
\citation{terabyte}
\citation{terabyte}
\citation{terabyte}
\citation{nyt_article}
\citation{end_of_moore}
\citation{mapreduce}
\citation{microsoft_merge_join}
\citation{eth_merge_join}
\citation{cloudsort}
\@writefile{toc}{\contentsline {section}{\numberline {1}Abstract}{3}{section.1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Introduction}{3}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}Current State-of-the-Art Results}{3}{subsection.2.1}}
\citation{alphasort}
\citation{joulesort}
\citation{tencent}
\citation{nadsort}
\citation{ntosort}
\citation{terabyte}
\citation{SIMD}
\citation{cache-friendly}
\citation{radix}
\citation{manycore}
\citation{gputera}
\citation{gpu_radix}
\citation{gpu_survey}
\citation{farmahini}
\citation{lhc}
\citation{fccm17}
\citation{fccm18}
\citation{camb}
\citation{fpgasort}
\citation{dbo}
\citation{unbalanced_fifo}
\citation{network}
\citation{eth}
\citation{usc}
\citation{usc2}
\citation{terabyte}
\citation{mit_merge_tree}
\citation{farmahini}
\citation{fccm17}
\citation{fccm18}
\citation{camb}
\citation{network}
\citation{fpgasort}
\citation{odb}
\citation{unbalanced_fifo}
\citation{eth}
\citation{usc}
\@writefile{lot}{\contentsline {table}{\numberline {1}{\ignorespaces sortbenchmark.org record holders.\relax }}{4}{table.caption.2}}
\providecommand*\caption@xref[2]{\@setref\relax\@undefined{#1}}
\newlabel{tab:benchmark}{{1}{4}{sortbenchmark.org record holders.\relax }{table.caption.2}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2}Survey of Previous Work}{4}{subsection.2.2}}
\citation{fccm18}
\citation{fccm18}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3}Merge Trees and Their Design Trade-Offs}{5}{subsection.2.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {1}{\ignorespaces The design of a Hardware Merger as described in \cite  {fccm18}.\relax }}{5}{figure.caption.3}}
\citation{fccm17}
\citation{terabyte}
\@writefile{lof}{\contentsline {figure}{\numberline {2}{\ignorespaces Example architecture of a Merge Tree with throughput $P=4$ and number of leaves $L=8$.\relax }}{6}{figure.caption.4}}
\newlabel{example_P4_L8}{{2}{6}{Example architecture of a Merge Tree with throughput $P=4$ and number of leaves $L=8$.\relax }{figure.caption.4}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4}Our Contribution}{6}{subsection.2.4}}
\@writefile{lof}{\contentsline {figure}{\numberline {3}{\ignorespaces Example architecture of a Merge Tree with throughput $P=4$ and number of leaves $L=16$.\relax }}{7}{figure.caption.5}}
\newlabel{example_P4_L16}{{3}{7}{Example architecture of a Merge Tree with throughput $P=4$ and number of leaves $L=16$.\relax }{figure.caption.5}{}}
\citation{terabyte}
\citation{fccm18}
\@writefile{toc}{\contentsline {section}{\numberline {3}Model}{8}{section.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {4}{\ignorespaces Logarithmic heatmap of Performance ($P\qopname  \relax o{log}2L$) as a function of the tree throughput ($P$) and number of leaves ($L$). Notice that Performance grows faster with the Merge Tree throughput ($P$) than with the number of leaves ($L$).\relax }}{8}{figure.caption.6}}
\newlabel{heatmap}{{4}{8}{Logarithmic heatmap of Performance ($P\log 2L$) as a function of the tree throughput ($P$) and number of leaves ($L$). Notice that Performance grows faster with the Merge Tree throughput ($P$) than with the number of leaves ($L$).\relax }{figure.caption.6}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}Search Space Optimization}{9}{subsection.3.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {5}{\ignorespaces Number of LUTs required by different Merge Trees: throughput ($P$) and number of leaves ($L$). This data is based on Vivado synthesis results.\relax }}{9}{figure.caption.7}}
\newlabel{luts}{{5}{9}{Number of LUTs required by different Merge Trees: throughput ($P$) and number of leaves ($L$). This data is based on Vivado synthesis results.\relax }{figure.caption.7}{}}
\@writefile{lot}{\contentsline {table}{\numberline {3}{\ignorespaces LUT utilization of Building-Block Elements\relax }}{10}{table.caption.9}}
\newlabel{tab:building_blocks}{{3}{10}{LUT utilization of Building-Block Elements\relax }{table.caption.9}{}}
\@writefile{lot}{\contentsline {table}{\numberline {2}{\ignorespaces The accuracy of our area model compared with our experimental results.\relax }}{10}{table.caption.8}}
\newlabel{tab:results}{{2}{10}{The accuracy of our area model compared with our experimental results.\relax }{table.caption.8}{}}
\newlabel{heatmap_area_curve}{{6a}{11}{The Performance heatmap with the area curve. The Merge Trees whose centers of their respective cells are under the curve require less than $200,000$ LUTs.\relax }{figure.caption.10}{}}
\newlabel{sub@heatmap_area_curve}{{a}{11}{The Performance heatmap with the area curve. The Merge Trees whose centers of their respective cells are under the curve require less than $200,000$ LUTs.\relax }{figure.caption.10}{}}
\newlabel{shaded_area}{{6b}{11}{The logarithmic Performance heatmap with the Merge Trees that fit on $200,000$ LUTs shaded in green.\relax }{figure.caption.10}{}}
\newlabel{sub@shaded_area}{{b}{11}{The logarithmic Performance heatmap with the Merge Trees that fit on $200,000$ LUTs shaded in green.\relax }{figure.caption.10}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {7}{\ignorespaces The logarithmic Performance heatmap with a throughput cut-off. In this example, the \textit  {off-chip memory bandwidth} is limited to at most $2^4 = 16$ elements per cycle. Any Merge Trees that have throughput higher than this value will not give better sorting performance, as the throughput will be limited by the off-chip memory bandwidth.\relax }}{12}{figure.caption.11}}
\newlabel{throughput_cutoff}{{7}{12}{The logarithmic Performance heatmap with a throughput cut-off. In this example, the \textit {off-chip memory bandwidth} is limited to at most $2^4 = 16$ elements per cycle. Any Merge Trees that have throughput higher than this value will not give better sorting performance, as the throughput will be limited by the off-chip memory bandwidth.\relax }{figure.caption.11}{}}
\citation{fccm18}
\@writefile{lof}{\contentsline {figure}{\numberline {8}{\ignorespaces The Performance heatmap for different Merge Tree Set sizes with the area cut-off. These graphs show which Merge Tree Sets can be implemented on $200,000$ LUTs.\relax }}{13}{figure.caption.12}}
\newlabel{four_things}{{8}{13}{The Performance heatmap for different Merge Tree Set sizes with the area cut-off. These graphs show which Merge Tree Sets can be implemented on $200,000$ LUTs.\relax }{figure.caption.12}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {9}{\ignorespaces The Performance heatmap similar to the one in Figure~\ref  {four_things}, with area cut-offs for $100,000$ (green), $200,000$ (purple), $300,000$ (blue), $400,000$ (black), $500,000$ (pink).\relax }}{13}{figure.caption.13}}
\newlabel{four_things_four}{{9}{13}{The Performance heatmap similar to the one in Figure~\ref {four_things}, with area cut-offs for $100,000$ (green), $200,000$ (purple), $300,000$ (blue), $400,000$ (black), $500,000$ (pink).\relax }{figure.caption.13}{}}
\citation{repo_link}
\citation{fccm18}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2}Data Skew}{14}{subsection.3.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.3}Model predictions}{14}{subsection.3.3}}
\@writefile{lot}{\contentsline {table}{\numberline {4}{\ignorespaces Optimal Merge Tree Sets $(C, P, L)$ with $C$ the number of Merge Trees in the set, $P$ the Merge Tree throughput, $L$ the number of leaves of the Merge Tree.\relax }}{14}{table.caption.14}}
\newlabel{tab:results_total}{{4}{14}{Optimal Merge Tree Sets $(C, P, L)$ with $C$ the number of Merge Trees in the set, $P$ the Merge Tree throughput, $L$ the number of leaves of the Merge Tree.\relax }{table.caption.14}{}}
\@writefile{lot}{\contentsline {table}{\numberline {5}{\ignorespaces The predicted total sorting time of the Optimal Merge Tree Sets $(C, P, L)$ specified in Table~\ref  {tab:results_total} on $10$GB of 32-bit integer arrays. Cycle-accurate simulations demonstrate that the end-to-end system would be at most 10\% slower than the times listed here.\relax }}{14}{table.caption.15}}
\newlabel{tab:results_total_2}{{5}{14}{The predicted total sorting time of the Optimal Merge Tree Sets $(C, P, L)$ specified in Table~\ref {tab:results_total} on $10$GB of 32-bit integer arrays. Cycle-accurate simulations demonstrate that the end-to-end system would be at most 10\% slower than the times listed here.\relax }{table.caption.15}{}}
\@writefile{toc}{\contentsline {section}{\numberline {4}Implementation}{14}{section.4}}
\citation{fccm18}
\citation{fccm18}
\citation{fccm18}
\citation{fccm18}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}Hardware Mergers}{15}{subsection.4.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {10}{\ignorespaces The design of a 16-element bitonic merger, which is used in the 8-element Hardware Merger.\relax }}{15}{figure.caption.16}}
\newlabel{bitonic_merger}{{10}{15}{The design of a 16-element bitonic merger, which is used in the 8-element Hardware Merger.\relax }{figure.caption.16}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {11}{\ignorespaces The design of a Hardware Merger as described in \cite  {fccm18}.\relax }}{15}{figure.caption.17}}
\citation{fccm18}
\citation{fccm18}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {4.1.1}Proof of Correctness}{16}{subsubsection.4.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {4.1.2}Fast Reset}{16}{subsubsection.4.1.2}}
\citation{fccm18}
\@writefile{lol}{\contentsline {lstlisting}{H}{17}{lstlisting.-1}}
\@writefile{lof}{\contentsline {figure}{\numberline {12}{\ignorespaces The FSM State Transition Logic\relax }}{17}{figure.caption.18}}
\newlabel{state_transition}{{12}{17}{The FSM State Transition Logic\relax }{figure.caption.18}{}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {4.1.3}Hardware Merger Control Logic}{17}{subsubsection.4.1.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {13}{\ignorespaces The stall signal logic\relax }}{18}{figure.caption.19}}
\newlabel{stall_logic}{{13}{18}{The stall signal logic\relax }{figure.caption.19}{}}
\@writefile{lof}{\contentsline {figure}{\numberline {14}{\ignorespaces The select logic\relax }}{18}{figure.caption.20}}
\newlabel{select_logic}{{14}{18}{The select logic\relax }{figure.caption.20}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}Merge Trees}{19}{subsection.4.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.3}DRAM Access Pattern and the Round Robin Skip}{19}{subsection.4.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {15}{\ignorespaces The data loading scheme.\relax }}{20}{figure.caption.21}}
\newlabel{DRAM}{{15}{20}{The data loading scheme.\relax }{figure.caption.21}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.4}Going Between Stages}{21}{subsection.4.4}}
\@writefile{lot}{\contentsline {table}{\numberline {6}{\ignorespaces Summary of the behavior of the different stages required to sort $2^{15}$ elements\relax }}{21}{table.caption.22}}
\newlabel{tab:stages}{{6}{21}{Summary of the behavior of the different stages required to sort $2^{15}$ elements\relax }{table.caption.22}{}}
\@writefile{lot}{\contentsline {table}{\numberline {7}{\ignorespaces Summary of the behavior of the different stages required to sort $2^{15}$ elements\relax }}{22}{table.caption.23}}
\newlabel{tab:updated}{{7}{22}{Summary of the behavior of the different stages required to sort $2^{15}$ elements\relax }{table.caption.23}{}}
\citation{fccm18}
\citation{terabyte}
\@writefile{toc}{\contentsline {section}{\numberline {5}Experimental Results}{23}{section.5}}
\@writefile{lot}{\contentsline {table}{\numberline {8}{\ignorespaces The optimal and measured number of cycles required for each of the $4$ stages required by the $(P,L)=(4,4)$ tree to sort $2^{15}$ elements. The optimal number of cycles reflects the number of cycles required to complete the stage if data skew, DRAM access latency issues, and dummy value overhead did not exist, that is, if the tree operated at $4 GB/s$. \textit  {Active rate} specifies the ratio of measured and optimal performance.\relax }}{24}{table.caption.24}}
\newlabel{tab:stages_cycles}{{8}{24}{The optimal and measured number of cycles required for each of the $4$ stages required by the $(P,L)=(4,4)$ tree to sort $2^{15}$ elements. The optimal number of cycles reflects the number of cycles required to complete the stage if data skew, DRAM access latency issues, and dummy value overhead did not exist, that is, if the tree operated at $4 GB/s$. \textit {Active rate} specifies the ratio of measured and optimal performance.\relax }{table.caption.24}{}}
\bibcite{fccm17}{1}
\bibcite{fccm18}{2}
\bibcite{camb}{3}
\bibcite{terabyte}{4}
\bibcite{nyt_article}{5}
\bibcite{end_of_moore}{6}
\bibcite{mapreduce}{7}
\bibcite{microsoft_merge_join}{8}
\bibcite{eth_merge_join}{9}
\bibcite{joulesort}{10}
\bibcite{cloudsort}{11}
\bibcite{alphasort}{12}
\bibcite{tencent}{13}
\bibcite{nadsort}{14}
\bibcite{ntosort}{15}
\bibcite{cache-friendly}{16}
\bibcite{SIMD}{17}
\bibcite{radix}{18}
\bibcite{manycore}{19}
\bibcite{gputera}{20}
\bibcite{gpu_radix}{21}
\bibcite{gpu_survey}{22}
\bibcite{farmahini}{23}
\bibcite{lhc}{24}
\bibcite{fpgasort}{25}
\bibcite{dbo}{26}
\bibcite{unbalanced_fifo}{27}
\bibcite{network}{28}
\bibcite{eth}{29}
\bibcite{usc}{30}
\bibcite{usc2}{31}
\bibcite{mit_merge_tree}{32}
\bibcite{repo_link}{33}
